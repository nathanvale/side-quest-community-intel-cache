/**
 * Raw markdown fallback formatter.
 *
 * Used when --no-synthesize is passed or when LLM synthesis fails.
 * Produces the same topic-by-topic, source-by-source format that the
 * Dell plugin's refresh-cache.ts originally generated.
 */

import type { Last30DaysReport } from './types.js'
import { TOP_N } from './types.js'

/** Check whether a report has any actual data across all source arrays. */
function hasData(report: Last30DaysReport): boolean {
	return report.reddit.length + report.x.length + report.web.length > 0
}

/**
 * Format raw query results into a markdown summary.
 *
 * Each topic gets a section with Reddit/X/Web subsections sorted by score.
 * Top N results per source type. Includes source URLs for attribution.
 */
export function formatMarkdown(
	results: Array<Last30DaysReport | null>,
	updatedAt: string,
): string {
	const lines: string[] = [
		'# Community Intelligence',
		'',
		`Auto-generated by \`community-intel-cache\` on ${updatedAt}.`,
		'',
	]

	for (const result of results) {
		if (!result) continue

		lines.push(`## ${result.topic}`, '')

		if (!hasData(result)) {
			lines.push('No significant community activity found for this topic.', '')
			continue
		}

		const allUrls: string[] = []

		// Reddit
		if (result.reddit.length > 0) {
			const sorted = [...result.reddit].sort((a, b) => b.score - a.score)
			lines.push('### Reddit', '')
			for (const item of sorted.slice(0, TOP_N)) {
				lines.push(`- [${item.title}](${item.url}) (r/${item.subreddit})`)
				lines.push(`  ${item.why_relevant}`)
				if (item.comment_insights.length > 0) {
					for (const insight of item.comment_insights) {
						lines.push(`  - ${insight}`)
					}
				}
				allUrls.push(item.url)
			}
			lines.push('')
		}

		// X posts
		if (result.x.length > 0) {
			const sorted = [...result.x].sort((a, b) => b.score - a.score)
			lines.push('### X (Twitter)', '')
			for (const item of sorted.slice(0, TOP_N)) {
				const preview =
					item.text.length > 120 ? `${item.text.slice(0, 120)}...` : item.text
				lines.push(`- [@${item.author_handle}](${item.url}): "${preview}"`)
				lines.push(`  ${item.why_relevant}`)
				allUrls.push(item.url)
			}
			lines.push('')
		}

		// Web results
		if (result.web.length > 0) {
			const sorted = [...result.web].sort((a, b) => b.score - a.score)
			lines.push('### Web', '')
			for (const item of sorted.slice(0, TOP_N)) {
				lines.push(`- [${item.title}](${item.url}) (${item.source_domain})`)
				lines.push(`  ${item.snippet}`)
				allUrls.push(item.url)
			}
			lines.push('')
		}

		// Sources list
		if (allUrls.length > 0) {
			lines.push('### Sources', '')
			for (const url of allUrls) {
				lines.push(`- ${url}`)
			}
			lines.push('')
		}
	}

	return lines.join('\n')
}
